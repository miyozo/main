
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ clear
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ clear
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ echo sehell_var
shell_var
[ec2-user@ip-172-31-3-152 ~]$ shell _var=test123
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ echo shell_var
shell_var
[ec2-user@ip-172-31-3-152 ~]$ echo shell_var$shell_var
test123
[ec2-user@ip-172-31-3-152 ~]$ set 
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:globskipdots:histappend:interactive_comments:login_shell:patsub_replacement:progcomp:promptvars:sourcepath
BASHRCSOURCED=Y
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="11")
BASH_LINENO=()
BASH_LOADABLES_PATH=/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:.
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="2" [2]="15" [3]="1" [4]="release" [5]="x86_64-amazon-linux-gnu")
BASH_VERSION='5.2.15(1)-release'
COLUMNS=157
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
DIRSTACK=()
EUID=1000
GROUPS=()
HISTCONTROL=ignoredups
HISTFILE=/home/ec2-user/.bash_history
HISTFILESIZE=1000
HISTSIZE=1000
HOME=/home/ec2-user
HOSTNAME=ip-172-31-3-152.ap-southeast-2.compute.internal
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=C.UTF-8
LESSOPEN='||/usr/bin/lesspipe.sh %s'
LINES=44
LOGNAME=ec2-user
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:'
MACHTYPE=x86_64-amazon-linux-gnu
MAIL=/var/spool/mail/ec2-user
MAILCHECK=60
MOTD_SHOWN=pam
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
PIPESTATUS=([0]="0")
PPID=5690
PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
PS1='[\u@\h \W]\$ '
PS2='> '
PS4='+ '
PWD=/home/ec2-user
SELINUX_LEVEL_REQUESTED=
SELINUX_ROLE_REQUESTED=
SELINUX_USE_CURRENT_RANGE=
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_CLIENT='101.1.235.76 51075 22'
SSH_CONNECTION='101.1.235.76 51075 172.31.3.152 22'
SSH_TTY=/dev/pts/1
SYSTEMD_COLORS=false
S_COLORS=auto
TERM=xterm
UID=1000
USER=ec2-user
XDG_RUNTIME_DIR=/run/user/1000
XDG_SESSION_CLASS=user
XDG_SESSION_ID=3
XDG_SESSION_TYPE=tty
_=test123
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [freeamp]="!*.@(mp3|ogg|pls|m3u)" [gqmpeg]="!*.@(mp3|ogg|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [rpm2cpio]="!*.[rs]pm" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [pbunzip2]="!*.?(t)bz?(2)" [lrunzip]="!*.lrz" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [znew]="*.Z" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [lzfgrep]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [zipinfo]="!*.@(zip|[aegjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [lokalize]="!*.po" [lbzcat]="!*.?(t)bz?(2)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [totem]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [dvitype]="!*.dvi" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdfunite]="!*.pdf" [gpdf]="!*.[pf]df" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [mpg123]="!*.mp3" [lzegrep]="!*.@(tlz|lzma)" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.[pf]df" [oobase]="!*.odb" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [bzcat]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lomath]="!*.@(sxm|smf|mml|odf)" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [dvipdf]="!*.dvi" [mpg321]="!*.mp3" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lobase]="!*.odb" [epdfview]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [poedit]="!*.po" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kbabel]="!*.po" [bzme]="!*.@(zip|z|gz|tgz)" [dviselect]="!*.dvi" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [gtranslator]="!*.po" [unzip]="!*.@(zip|[aegjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [oomath]="!*.@(sxm|smf|mml|odf)" [dvipdfmx]="!*.dvi" [makeinfo]="!*.texi*" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvipdfm]="!*.dvi" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvips]="!*.dvi" [ps2pdf]="!*.@(?(e)ps|pdf)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lzgrep]="!*.@(tlz|lzma)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [unlzma]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [lilypond]="!*.ly" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [pbzcat]="!*.?(t)bz?(2)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzcat]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [advi]="!*.dvi" [lzmore]="!*.@(tlz|lzma)" )
colors=/home/ec2-user/.dircolors
shell_var=test123
which_declare='declare -f'
which_opt=-f
which_shell=bash
__expand_tilde_by_ref () 
{ 
    if [[ ${!1-} == \~* ]]; then
        eval $1="$(printf ~%q "${!1#\~}")";
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur="" index=$COMP_POINT lead=${COMP_LINE:0:COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]/} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i))
        do
            while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]-}" ]]; do
                cur="${cur:1}";
                ((index > 0)) && ((index--));
            done;
            if ((i < cword)); then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                ((index -= old_size - new_size));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]/} ]] && cur=;
        ((index < 0)) && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 ${words+"${words[@]}"} -v $3 "$cword" -v $4 "${cur:0:index}"
}
__load_completion () 
{ 
    local -a dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions);
    local ifs=$IFS IFS=: dir cmd="${1##*/}" compfile;
    [[ -n $cmd ]] || return 1;
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    do
        dirs+=($dir/bash-completion/completions);
    done;
    IFS=$ifs;
    if [[ $BASH_SOURCE == */* ]]; then
        dirs+=("${BASH_SOURCE%/*}/completions");
    else
        dirs+=(./completions);
    fi;
    local backslash=;
    if [[ $cmd == \\* ]]; then
        cmd="${cmd:1}";
        $(complete -p "$cmd" 2> /dev/null || echo false) "\\$cmd" && return 0;
        backslash=\\;
    fi;
    for dir in "${dirs[@]}";
    do
        [[ -d $dir ]] || continue;
        for compfile in "$cmd" "$cmd.bash" "_$cmd";
        do
            compfile="$dir/$compfile";
            if [[ -f $compfile ]] && . "$compfile" &> /dev/null; then
                [[ -n $backslash ]] && $(complete -p "$cmd") "\\$cmd";
                return 0;
            fi;
        done;
    done;
    [[ -v _xspecs[$cmd] ]] && complete -F _filedir_xspec "$cmd" "$backslash$cmd" && return 0;
    return 1
}
__ltrim_colon_completions () 
{ 
    if [[ $1 == *:* && $COMP_WORDBREAKS == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while ((i-- > 0)); do
            COMPREPLY[i]=${COMPREPLY[i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    local -a array=($1);
    for i in "${array[@]}";
    do
        case "$i" in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="[${1//[^$COMP_WORDBREAKS]/}]";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -v exclude ]]; then
        line=$COMP_LINE;
        for ((i = 0, j = 0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[i]} == +($exclude) ]]; do
                [[ $line != [[:blank:]]* ]] && ((j >= 2)) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
                ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[i]}"};
                [[ $line == [[:blank:]]* ]] && ((j++));
                ((i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
        done;
        ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -g -- "$1"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W "$(id -Gn 2> /dev/null || groups 2> /dev/null)" -- "$1"));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -u -- "${1:-$cur}"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W "$(id -un 2> /dev/null || whoami 2> /dev/null)" -- "${1:-$cur}"));
    fi
}
_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY=($({ if [[ ${1:-} == -w ]]; then
    iwconfig;
else
    if [[ ${1:-} == -a ]]; then
        ifconfig || ip link show up;
    else
        ifconfig -a || ip link show;
    fi;
fi; } 2> /dev/null | awk '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }'));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur"))
}
_bashcomp_try_faketty () 
{ 
    if type unbuffer &> /dev/null; then
        unbuffer -p "$@";
    else
        if script --version 2>&1 | command grep -qF util-linux; then
            script -qaefc "$*" /dev/null;
        else
            "$@";
        fi;
    fi
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z ${CDPATH:-} || $cur == ?(.)?(.)/* ]]; then
        _filedir -d;
        return;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $(compgen -d -- $i/$cur);
        do
            if [[ ( -n $mark_symdirs && -L $j || -n $mark_dirs && ! -L $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if ((${#COMPREPLY[@]} == 1)); then
        i=${COMPREPLY[0]};
        if [[ $i == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return
}
_cd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}"))
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i = 1; i <= COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i = 0; i < word_offset; i++))
    do
        for ((j = 0; j <= ${#COMP_LINE}; j++))
        do
            [[ $COMP_LINE == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT -= ${#COMP_WORDS[i]}));
    done;
    for ((i = 0; i <= COMP_CWORD - word_offset; i++))
    do
        COMP_WORDS[i]=${COMP_WORDS[i + word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++))
    do
        unset 'COMP_WORDS[i]';
    done;
    ((COMP_CWORD -= word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if ((COMP_CWORD == 0)); then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($(compgen -d -c -- "$cur"));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$(complete -p $cmd 2> /dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p ${cmd##*/} 2> /dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$(complete -p $compcmd 2> /dev/null);
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != "$cspec" ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if ((${#COMP_WORDS[@]} >= 2)); then
                    $func $cmd "${COMP_WORDS[-1]}" "${COMP_WORDS[-2]}";
                else
                    $func $cmd "${COMP_WORDS[-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($(eval compgen "$cspec" -- '$cur'));
            fi;
        else
            if ((${#COMPREPLY[@]} == 0)); then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local cmd="${1:-_EmptycmD_}";
    __load_completion "$cmd" && return 124;
    complete -F _minimal -- "$cmd" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($(compgen -W "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p' /etc/network/interfaces /etc/network/interfaces.d/* 2> /dev/null)" -- "$cur"));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($(compgen -W "$(printf '%s\n' /etc/sysconfig/network/ifcfg-* | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($(compgen -W "$(command ls -B /etc/sysconfig/interfaces | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            else
                COMPREPLY=($(compgen -W "$(printf '%s\n' /etc/sysconfig/network-scripts/ifcfg-* | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "${1-}" words cword;
    args=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ ${words[i]} != -* && ${words[i - 1]} != ${2-} || ${words[i]} == ${3-} ]]; then
            ((args++));
        fi;
    done
}
_dvd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}"))
}
_expand () 
{ 
    case ${cur-} in 
        ~*/*)
            __expand_tilde_by_ref cur
        ;;
        ~*)
            _tilde "$cur" || eval COMPREPLY[0]="$(printf ~%q "${COMPREPLY[0]#\~}")";
            return ${#COMPREPLY[@]}
        ;;
    esac
}
_filedir () 
{ 
    local IFS='
';
    _tilde "${cur-}" || return;
    local -a toks;
    local reset arg=${1-};
    if [[ $arg == -d ]]; then
        reset=$(shopt -po noglob);
        set -o noglob;
        toks=($(compgen -d -- "${cur-}"));
        IFS=' ';
        $reset;
        IFS='
';
    else
        local quoted;
        _quote_readline_by_ref "${cur-}" quoted;
        local xspec=${arg:+"!*.@($arg|${arg^^})"} plusdirs=();
        local opts=(-f -X "$xspec");
        [[ -n $xspec ]] && plusdirs=(-o plusdirs);
        [[ -n ${COMP_FILEDIR_FALLBACK-} || -z ${plusdirs-} ]] || opts+=("${plusdirs[@]}");
        reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen "${opts[@]}" -- $quoted));
        IFS=' ';
        $reset;
        IFS='
';
        [[ -n ${COMP_FILEDIR_FALLBACK-} && -n $arg && ${#toks[@]} -lt 1 ]] && { 
            reset=$(shopt -po noglob);
            set -o noglob;
            toks+=($(compgen -f ${plusdirs+"${plusdirs[@]}"} -- $quoted));
            IFS=' ';
            $reset;
            IFS='
'
        };
    fi;
    if ((${#toks[@]} != 0)); then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(compgen -d -- "$(quote_readline "$cur")" | { while read -r tmp; do
    printf '%s\n' $tmp;
done; }));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(eval compgen -f -X "'!$xspec'" -- '$(quote_readline "$cur")' | { while read -r tmp; do
    [[ -n $tmp ]] && printf '%s\n' $tmp;
done; }));
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && ${#toks[@]} -lt 1 ]] && { 
        local reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen -f -- "$(quote_readline "$cur")"));
        IFS=' ';
        $reset;
        IFS='
'
    };
    if ((${#toks[@]} != 0)); then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$(cut -d'	' -f2 /proc/filesystems)
             $(awk '! /\*/ { print $NF }' /etc/filesystems 2> /dev/null)";
    else
        fss="$(awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2> /dev/null)
             $(awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2> /dev/null)
             $(awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2> /dev/null)
             $(awk '{ print $1 }' /etc/dfs/fstypes 2> /dev/null)
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($(compgen -W "$fss" -- "$cur"))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        ((OPTIND += 1));
    done;
    __get_cword_at_cursor_by_ref "${exclude-}" words cword cur;
    [[ -v vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -v vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -v vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -v vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords ${words+"${words[@]}"})
    };
    ((${#upvars[@]})) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "${1-}" words cword;
    if [[ -n ${2-} && -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword - $2]}";
    else
        if ((${#words[cword]} == 0 && COMP_POINT == ${#COMP_LINE})); then
            :;
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i))
            do
                while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index > 0)) && ((index--));
                done;
                if ((i < cword)); then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    ((index -= old_size - new_size));
                fi;
            done;
            if [[ ${words[cword]:0:${#cur}} != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i = 1; i < COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if ((COMP_CWORD >= 1)); then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent group | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/group)' -- "$cur"));
        fi;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_included_ssh_config_files () 
{ 
    (($# < 1)) && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i f;
    configfile=$1;
    local reset=$(shopt -po noglob);
    set -o noglob;
    local included=($(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\(.*\)$/\1/p' "${configfile}"));
    $reset;
    [[ -n ${included-} ]] || return;
    for i in "${included[@]}";
    do
        if ! [[ $i =~ ^\~.*|^\/.* ]]; then
            if [[ $configfile =~ ^\/etc\/ssh.* ]]; then
                i="/etc/ssh/$i";
            else
                i="$HOME/.ssh/$i";
            fi;
        fi;
        __expand_tilde_by_ref i;
        set +o noglob;
        for f in $i;
        do
            if [[ -r $f ]]; then
                config+=("$f");
                _included_ssh_config_files $f;
            fi;
        done;
        $reset;
    done
}
_init_completion () 
{ 
    local exclude="" flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || ${prev-} == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=${errx-}
            ;;
            *'>'*)
                xspec=${outx-}
            ;;
            *'<'*)
                xspec=${inx-}
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=${errx-}
                    ;;
                    *'>'*)
                        xspec=${outx-}
                    ;;
                    *'<'*)
                        xspec=${inx-}
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i = 1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            ((i <= cword)) && ((cword -= skip));
        else
            ((i++));
        fi;
    done;
    ((cword <= 0)) && return 1;
    prev=${words[cword - 1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($(compgen -W "$(PATH="$PATH:/sbin" lsmod | awk '{if (NR != 1) print $1}')" -- "$1"))
}
_ip_addresses () 
{ 
    local n;
    case ${1-} in 
        -a)
            n='6\?'
        ;;
        -6)
            n='6'
        ;;
        *)
            n=
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs=$({ LC_ALL=C ifconfig -a || ip addr show; } 2> /dev/null | command sed -e 's/[[:space:]]addr:/ /' -ne "s|.*inet${n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p");
    COMPREPLY+=($(compgen -W "$addrs" -- "${cur-}"))
}
_kernel_versions () 
{ 
    COMPREPLY=($(compgen -W '$(command ls /lib/modules)' -- "$cur"))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ ${1-} == -a || ${2-} == -a ]] && options=-a;
    [[ ${1-} == -c || ${2-} == -c ]] && options+=" -c";
    _known_hosts_real ${options-} -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix="" ifs=$IFS;
    local cur suffix="" aliases i host ipv4 ipv6;
    local -a kh tmpkh=() khd=() config=();
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=1
            ;;
            6)
                ipv6=1
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    if (($# < OPTIND)); then
        echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
        return 1;
    fi;
    cur=${!OPTIND};
    ((OPTIND += 1));
    if (($# >= OPTIND)); then
        echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" "$(while (($# >= OPTIND)); do
    printf '%s ' ${!OPTIND}
shift;
done)" 1>&2;
        return 1;
    fi;
    [[ $cur == *@* ]] && prefix=$prefix${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -v configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    local reset=$(shopt -po noglob);
    set -o noglob;
    if ((${#config[@]} > 0)); then
        for i in "${config[@]}";
        do
            _included_ssh_config_files "$i";
        done;
    fi;
    if ((${#config[@]} > 0)); then
        local IFS='
';
        tmpkh=($(awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u));
        IFS=$ifs;
    fi;
    if ((${#tmpkh[@]} != 0)); then
        local j;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ ! -v configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if ((${#kh[@]} + ${#khd[@]} > 0)); then
        if ((${#kh[@]} > 0)); then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    ((${#tmpkh[@]} == 0)) && continue;
                    set -- "${tmpkh[@]}";
                    [[ $1 == [\|\#]* ]] && continue;
                    [[ $1 == @* ]] && shift;
                    local IFS=,;
                    for host in $1;
                    do
                        [[ $host == *[*?]* ]] && continue;
                        host="${host#[}";
                        host="${host%]?(:+([0-9]))}";
                        COMPREPLY+=($host);
                    done;
                    IFS=$ifs;
                done < "$i";
            done;
            COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
        fi;
        if ((${#khd[@]} > 0)); then
            for i in "${khd[@]}";
            do
                if [[ $i == *key_22_$cur*.pub && -r $i ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for i in ${!COMPREPLY[*]};
        do
            COMPREPLY[i]=$prefix${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -v aliases ]]; then
        local -a hosts=($(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]]\(.*\)$/\1/p' "${config[@]}"));
        if ((${#hosts[@]} != 0)); then
            COMPREPLY+=($(compgen -P "$prefix" -S "$suffix" -W '${hosts[@]%%[*?%]*}' -X '\!*' -- "$cur"));
        fi;
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI-} ]] && type avahi-browse &> /dev/null; then
        COMPREPLY+=($(compgen -P "$prefix" -S "$suffix" -W "$(avahi-browse -cpr _workstation._tcp 2> /dev/null | awk -F';' '/^=/ { print $7 }' | sort -u)" -- "$cur"));
    fi;
    if type ruptime &> /dev/null; then
        COMPREPLY+=($(compgen -W "$(ruptime 2> /dev/null | awk '!/^ruptime:/ { print $1 }')" -- "$cur"));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($(compgen -A hostname -P "$prefix" -S "$suffix" -- "$cur"));
    fi;
    $reset;
    if [[ -v ipv4 ]]; then
        COMPREPLY=("${COMPREPLY[@]/*:*$suffix/}");
    fi;
    if [[ -v ipv6 ]]; then
        COMPREPLY=("${COMPREPLY[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -v ipv4 || -v ipv6 ]]; then
        for i in "${!COMPREPLY[@]}";
        do
            [[ -n ${COMPREPLY[i]} ]] || unset -v "COMPREPLY[i]";
        done;
    fi;
    __ltrim_colon_completions "$prefix$cur"
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return
                ;;
                *file* | *path*)
                    _filedir;
                    return
                ;;
            esac
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W "$(LC_ALL=C $1 --help 2>&1 | while read -r line; do
    [[ $line =~ --[A-Za-z0-9]+([-_][A-Za-z0-9]+)*=? ]] && printf '%s\n' ${BASH_REMATCH[0]};
done)" -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    else
        if [[ $1 == *@(rmdir|chroot) ]]; then
            _filedir -d;
        else
            [[ $1 == *mkdir ]] && compopt -o nospace;
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($({ LC_ALL=C ifconfig -a || ip link show; } 2> /dev/null | command sed -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"));
    COMPREPLY+=($({ arp -an || ip neigh show; } 2> /dev/null | command sed -ne "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p"));
    COMPREPLY+=($(command sed -ne "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2> /dev/null));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($(compgen -W "$(command ls -RL $modpath 2> /dev/null | command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p')" -- "$cur"))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$(getconf $var 2> /dev/null);
    printf %s ${n:-1}
}
_parse_help () 
{ 
    eval local cmd="$(quote "$1")";
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([[:blank:]])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd="$(quote "$1")";
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i = 1; i < ${#option}; i++))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pci_ids () 
{ 
    COMPREPLY+=($(compgen -W "$(PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur"))
}
_pgids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pgid=)' -- "$cur"))
}
_pids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pid=)' -- "$cur"))
}
_pnames () 
{ 
    local -a procs;
    if [[ ${1-} == -s ]]; then
        procs=($(command ps axo comm | command sed -e 1d));
    else
        local line i=-1 ifs=$IFS;
        IFS='
';
        local -a psout=($(command ps axo command=));
        IFS=$ifs;
        for line in "${psout[@]}";
        do
            if ((i == -1)); then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:i};
                line=${line%% *};
                procs+=($line);
            fi;
        done;
        if ((i == -1)); then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=(${BASH_REMATCH[1]});
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    procs+=($line);
                fi;
            done;
        fi;
    fi;
    COMPREPLY=($(compgen -X "<defunct>" -W '${procs[@]}' -- "$cur"))
}
_quote_readline_by_ref () 
{ 
    if [[ $1 == \'* ]]; then
        printf -v $2 %s "${1:1}";
    else
        printf -v $2 %q "$1";
    fi;
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$(bind -v)" == *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    ((cword > 2)) && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($(compgen -W '`command sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur"));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local IFS=' 	
' reset=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($(printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions|README)));
    $reset;
    COMPREPLY+=($({ systemctl list-units --full --all || systemctl list-unit-files; } 2> /dev/null | awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }'));
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        COMPREPLY+=($(initctl list 2> /dev/null | cut -d' ' -f1));
    fi;
    COMPREPLY=($(compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur"))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($(compgen -P "${1-}" -A signal "SIG${cur#${1-}}"));
    COMPREPLY+=("${sigs[@]/#${1-}SIG/${1-}}")
}
_split_longopt () 
{ 
    if [[ $cur == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    return 0
}
_terms () 
{ 
    COMPREPLY+=($(compgen -W "$({ command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap
{ toe -a || toe; } | awk '{ print $1 }'
find /{etc,lib,usr/lib,usr/share}/terminfo/? -type f -maxdepth 1 | awk -F/ '{ print $NF }'; } 2> /dev/null)" -- "$cur"))
}
_tilde () 
{ 
    local result=0;
    if [[ ${1-} == \~* && $1 != */* ]]; then
        COMPREPLY=($(compgen -P '~' -u -- "${1#\~}"));
        result=${#COMPREPLY[@]};
        ((result > 0)) && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent passwd | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/passwd)' -- "$cur"));
        fi;
    fi
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _upvars instead" 1>&2;
    if unset -v "$1"; then
        if (($# == 2)); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\$"{@:2}"\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (($#)); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (($#)); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\$"{@:3:${1#-a}}"\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($(compgen -W "$(PATH="$PATH:/sbin" lsusb | awk '{print $6}')" -- "$cur"))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($(compgen -u -S @ -- "$cur"));
        compopt -o nospace;
    fi
}
_usergroup () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\/};
            local mycur="${cur#*[:]}";
            if [[ ${1-} == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($(compgen -g -- "$mycur"));
            fi;
            COMPREPLY=($(compgen -P "$prefix" -W "${COMPREPLY[@]}"));
        else
            if [[ $cur == *:* ]]; then
                local mycur="${cur#*:}";
                if [[ ${1-} == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -g -- "$mycur"));
                fi;
            else
                if [[ ${1-} == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -u -- "$cur"));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == "$1" ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == '${'* ]]; then
            local arrs vars;
            vars=($(compgen -A variable -P ${BASH_REMATCH[1]} -S '}' -- ${BASH_REMATCH[3]}));
            arrs=($(compgen -A arrayvar -P ${BASH_REMATCH[1]} -S '[' -- ${BASH_REMATCH[3]}));
            if ((${#vars[@]} == 1 && ${#arrs[@]} != 0)); then
                compopt -o nospace;
                COMPREPLY+=(${arrs[*]});
            else
                COMPREPLY+=(${vars[*]});
            fi;
        else
            COMPREPLY+=($(compgen -A variable -P '$' -- "${BASH_REMATCH[3]}"));
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local IFS='
';
            COMPREPLY+=($(compgen -W '$(printf %s\\n "${!'${BASH_REMATCH[2]}'[@]}")' -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}' -- "${BASH_REMATCH[3]}"));
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                COMPREPLY+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            __ltrim_colon_completions "$cur";
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                COMPREPLY+=("$cur}");
                __ltrim_colon_completions "$cur";
                return 0;
            else
                case ${prev-} in 
                    TZ)
                        cur=/usr/share/zoneinfo/$cur;
                        _filedir;
                        for i in "${!COMPREPLY[@]}";
                        do
                            if [[ ${COMPREPLY[i]} == *.tab ]]; then
                                unset 'COMPREPLY[i]';
                                continue;
                            else
                                if [[ -d ${COMPREPLY[i]} ]]; then
                                    COMPREPLY[i]+=/;
                                    compopt -o nospace;
                                fi;
                            fi;
                            COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                        done;
                        return 0
                    ;;
                    TERM)
                        _terms;
                        return 0
                    ;;
                    LANG | LC_*)
                        COMPREPLY=($(compgen -W '$(locale -a 2>/dev/null)' -- "$cur"));
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || __load_completion "$srcfile";
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=${BASHCOMP_XINETDDIR:-/etc/xinetd.d};
    if [[ -d $xinetddir ]]; then
        local IFS=' 	
' reset=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($(printf '%s\n' $xinetddir/!($_backup_glob)));
        $reset;
        ((!${#svcs[@]})) || COMPREPLY+=($(compgen -W '${svcs[@]#$xinetddir/}' -- "${cur-}"));
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
gawklibpath_append () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
}
gawklibpath_default () 
{ 
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
}
gawklibpath_prepend () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
}
gawkpath_append () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
}
gawkpath_default () 
{ 
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
}
gawkpath_prepend () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local ret;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
which () 
{ 
    ( alias;
    eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot "$@"
}
[ec2-user@ip-172-31-3-152 ~]$ set grep| grep sheell
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:globskipdots:histappend:interactive_comments:login_shell:patsub_replacement:progcomp:promptvars:sourcepath
shell_var=test123
which_shell=bash
_shells () 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ psps1set | PS1gPS1rPS1ePS1pPS1 PS1
PS1='[\u@\h \W]\$ '
[ec2-user@ip-172-31-3-152 ~]$ set | grep PS111p1s1
[ec2-user@ip-172-31-3-152 ~]$ set | grep ps1PS1
PS1='[\u@\h \W]\$ '
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ ^C
[ec2-user@ip-172-31-3-152 ~]$ ^CPS1='[\u@\h \W]\$ 'PS1='[\u@\h \W]\$ ' \t
[ec2-user@ip-172-31-3-152 ~ 11:05:40]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:41]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:42]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:42]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:42]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:42]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:42]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:43]$ 
[ec2-user@ip-172-31-3-152 ~ 11:05:43]$ PS1='[\u@\h \W \t]\$ '[Aset | grep PS1ps1PS1PS1='[\u@\h \[At]\$ '^C
[ec2-user@ip-172-31-3-152 ~ 11:06:18]$ PS1='[\u@\h \W]\$ 'PS1='[\u@\h \W]\$ '
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ sh
sh-5.2$ 
sh-5.2$ 
sh-5.2$ echo $PS1
\s-\v\$
sh-5.2$ 
sh-5.2$ 
sh-5.2$ 
sh-5.2$ echo $shell_var

sh-5.2$ exoiit
exit
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ exportprintent | grep shvnvhell
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ expiort shll_var
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ export shll_varprintenv | grep shell
[ec2-user@ip-172-31-3-152 ~]$ printenv | grep shellexport shll_varell_var
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ export shell_varprintenv | grep shell
shell_var=test123
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ sh
sh-5.2$ 
sh-5.2$ 
sh-5.2$ 
sh-5.2$ echo shell_var
shell_var
sh-5.2$ echo shell_var$shell_var
test123
sh-5.2$ 
sh-5.2$ 
sh-5.2$ 
sh-5.2$ exit
exit
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ less l
total 8
-rw-r--r--. 1 ec2-user ec2-user   0 Feb 28 09:52 a
-rw-r--r--. 1 ec2-user ec2-user   6 Feb 28 09:57 b
-rw-r--r--. 1 ec2-user ec2-user 389 Feb 28 10:03 ssh_process.txt
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ less ssh_process.txt
root        2156  0.0  0.8  13316  8320 ?        Ss   09:34   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root        2477  0.0  1.0  14776 10016 ?        Ss   09:40   0:00 sshd: ec2-user [priv]
ec2-user    2498  0.0  0.6  14776  6344 ?        S    09:40   0:00 sshd: ec2-user@pts/0
ec2-user    3345  0.0  0.2 222316  2056 pts/0    S+   10:03   0:00 grep --color=auto ssh
ssh_process.txt (END) ESCESCOOAA...skipping...
root        2156  0.0  0.8  13316  8320 ?        Ss   09:34   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root        2477  0.0  1.0  14776 10016 ?        Ss   09:40   0:00 sshd: ec2-user [priv]
ec2-user    2498  0.0  0.6  14776  6344 ?        S    09:40   0:00 sshd: ec2-user@pts/0
ec2-user    3345  0.0  0.2 222316  2056 pts/0    S+   10:03   0:00 grep --color=auto ssh
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOAA(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END) ESCESCOOBB(END)[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ man less
LESS(1)                                                          General Commands Manual                                                          LESS(1)

NAME
       less - opposite of more

SYNOPSIS
       less -?
       less --help
       less -V
       less --version
       less [-[+]aABcCdeEfFgGiIJKLmMnNqQrRsSuUVwWX~]
            [-b space] [-h lines] [-j line] [-k keyfile]
            [-{oO} logfile] [-p pattern] [-P prompt] [-t tag]
            [-T tagsfile] [-x tab,...] [-y lines] [-[z] lines]
            [-# shift] [+[+]cmd] [--] [filename]...
       (See the OPTIONS section for alternate option syntax with long option names.)

DESCRIPTION
       Less  is  a  program  similar to more(1), but which allows backward movement in the file as well as forward movement.  Also, less does not have to
       read the entire input file before starting, so with large input files it starts up faster than text editors like vi(1).   Less  uses  termcap  (or
       terminfo  on some systems), so it can run on a variety of terminals.  There is even limited support for hardcopy terminals.  (On a hardcopy termi‐
       nal, lines which should be printed at the top of the screen are prefixed with a caret.)

       Commands are based on both more and vi.  Commands may be preceded by a decimal number, called N in the descriptions below.  The number is used  by
       some commands, as indicated.

COMMANDS
       In  the  following  descriptions, ^X means control-X.  ESC stands for the ESCAPE key; for example ESC-v means the two character sequence "ESCAPE",
       then "v".

       h or H Help: display a summary of these commands.  If you forget all the other commands, remember this one.

       SPACE or ^V or f or ^F
              Scroll forward N lines, default one window (see option -z below).  If N is more than the screen size, only  the  final  screenful  is  dis‐
              played.  Warning: some systems use ^V as a special literalization character.

       z      Like SPACE, but if N is specified, it becomes the new window size.

       ESC-SPACE
              Like SPACE, but scrolls a full screenful, even if it reaches end-of-file in the process.

       ENTER or RETURN or ^N or e or ^E or j or ^J
              Scroll forward N lines, default 1.  The entire N lines are displayed, even if N is more than the screen size.
 Manual page less(1) line 1 (press h for help or q to quit) Manual page less(1) line 1 (press h for help or q to quit) Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit) ESCESCOOAA Manual page less(1) line 1 (press h for help or q to quit)[ec2-user@ip-172-31-3-152 ~]$ man less
LESS(1)                                                          General Commands Manual                                                          LESS(1)

NAME
       less - opposite of more

SYNOPSIS
       less -?
       less --help
       less -V
       less --version
       less [-[+]aABcCdeEfFgGiIJKLmMnNqQrRsSuUVwWX~]
            [-b space] [-h lines] [-j line] [-k keyfile]
            [-{oO} logfile] [-p pattern] [-P prompt] [-t tag]
            [-T tagsfile] [-x tab,...] [-y lines] [-[z] lines]
            [-# shift] [+[+]cmd] [--] [filename]...
       (See the OPTIONS section for alternate option syntax with long option names.)

DESCRIPTION
       Less  is  a  program  similar to more(1), but which allows backward movement in the file as well as forward movement.  Also, less does not have to
       read the entire input file before starting, so with large input files it starts up faster than text editors like vi(1).   Less  uses  termcap  (or
       terminfo  on some systems), so it can run on a variety of terminals.  There is even limited support for hardcopy terminals.  (On a hardcopy termi‐
       nal, lines which should be printed at the top of the screen are prefixed with a caret.)

       Commands are based on both more and vi.  Commands may be preceded by a decimal number, called N in the descriptions below.  The number is used  by
       some commands, as indicated.

COMMANDS
       In  the  following  descriptions, ^X means control-X.  ESC stands for the ESCAPE key; for example ESC-v means the two character sequence "ESCAPE",
       then "v".

       h or H Help: display a summary of these commands.  If you forget all the other commands, remember this one.

       SPACE or ^V or f or ^F
              Scroll forward N lines, default one window (see option -z below).  If N is more than the screen size, only  the  final  screenful  is  dis‐
              played.  Warning: some systems use ^V as a special literalization character.

       z      Like SPACE, but if N is specified, it becomes the new window size.

       ESC-SPACE
              Like SPACE, but scrolls a full screenful, even if it reaches end-of-file in the process.

       ENTER or RETURN or ^N or e or ^E or j or ^J
              Scroll forward N lines, default 1.  The entire N lines are displayed, even if N is more than the screen size.
 Manual page less(1) line 1 (press h for help or q to quit)
       d or ^D
              Scroll  forward  N  lines,  default one half of the screen size.  If N is specified, it becomes the new default for subsequent d and u com‐
              mands.

       b or ^B or ESC-v
              Scroll backward N lines, default one window (see option -z below).  If N is more than the screen size, only the  final  screenful  is  dis‐
              played.

       w      Like ESC-v, but if N is specified, it becomes the new window size.

       y or ^Y or ^P or k or ^K
              Scroll  backward  N lines, default 1.  The entire N lines are displayed, even if N is more than the screen size.  Warning: some systems use
              ^Y as a special job control character.

       u or ^U
              Scroll backward N lines, default one half of the screen size.  If N is specified, it becomes the new default for subsequent d  and  u  com‐
              mands.

       J      Like j, but continues to scroll beyond the end of the file.

       K or Y Like k, but continues to scroll beyond the beginning of the file.

       ESC-) or RIGHTARROW
              Scroll  horizontally right N characters, default half the screen width (see the -# option).  If a number N is specified, it becomes the de‐
              fault for future RIGHTARROW and LEFTARROW commands.  While the text is scrolled, it acts as though the -S option (chop lines) were  in  ef‐
              fect.

       ESC-( or LEFTARROW
              Scroll  horizontally  left N characters, default half the screen width (see the -# option).  If a number N is specified, it becomes the de‐
              fault for future RIGHTARROW and LEFTARROW commands.

       ESC-} or ^RIGHTARROW
              Scroll horizontally right to show the end of the longest displayed line.

       ESC-{ or ^LEFTARROW
              Scroll horizontally left back to the first column.

       r or ^R or ^L
              Repaint the screen.

       R      Repaint the screen, discarding any buffered input.  That is, reload the current file.  Useful if the file is changing  while  it  is  being
              viewed.
 Manual page less(1) line 44 (press h for help or q to quit)
       F      Scroll  forward,  and  keep trying to read when the end of file is reached.  Normally this command would be used when already at the end of
              the file.  It is a way to monitor the tail of a file which is growing while it is being viewed.  (The behavior is similar to the "tail  -f"
              command.)   To  stop waiting for more data, enter the interrupt character (usually ^C).  On some systems you can also use ^X.  If the input
              is a pipe and the --exit-follow-on-close option is in effect, less will automatically stop waiting for data when the input side of the pipe
              is closed.

       ESC-F  Like F, but as soon as a line is found which matches the last search pattern, the terminal bell is rung and forward scrolling stops.

       g or < or ESC-<
              Go to line N in the file, default 1 (beginning of file).  (Warning: this may be slow if N is large.)

       G or > or ESC->
              Go to line N in the file, default the end of the file.  (Warning: this may be slow if N is large, or if N is not specified and standard in‐
              put, rather than a file, is being read.)

       ESC-G  Same as G, except if no number N is specified and the input is standard input, goes to the last line which is currently buffered.

       p or % Go to a position N percent into the file.  N should be between 0 and 100, and may contain a decimal point.

       P      Go to the line containing byte offset N in the file.

       {      If a left curly bracket appears in the top line displayed on the screen, the { command will go to the matching right  curly  bracket.   The
              matching right curly bracket is positioned on the bottom line of the screen.  If there is more than one left curly bracket on the top line,
              a number N may be used to specify the N-th bracket on the line.

       }      If a right curly bracket appears in the bottom line displayed on the screen, the } command will go to the matching left curly bracket.  The
              matching left curly bracket is positioned on the top line of the screen.  If there is more than one right curly bracket on the bottom line,
              a number N may be used to specify the N-th bracket on the line.

       (      Like {, but applies to parentheses rather than curly brackets.

       )      Like }, but applies to parentheses rather than curly brackets.

       [      Like {, but applies to square brackets rather than curly brackets.

       ]      Like }, but applies to square brackets rather than curly brackets.

       ESC-^F Followed by two characters, acts like {, but uses the two characters as open and close brackets, respectively.  For example, "ESC ^F  <  >"
              could be used to go forward to the > which matches the < in the top displayed line.

       ESC-^B Followed  by  two characters, acts like }, but uses the two characters as open and close brackets, respectively.  For example, "ESC ^B < >"
              could be used to go backward to the < which matches the > in the bottom displayed line.
 Manual page less(1) line 87 (press h for help or q to quit)
       m      Followed by any lowercase or uppercase letter, marks the first displayed line with that letter.  If the status column is enabled via the -J
              option, the status column shows the marked line.

       M      Acts like m, except the last displayed line is marked rather than the first displayed line.

       '      (Single quote.)  Followed by any lowercase or uppercase letter, returns to the position which was previously marked with that letter.  Fol‐
              lowed by another single quote, returns to the position at which the last "large" movement command was executed.  Followed  by  a  ^  or  $,
              jumps  to  the beginning or end of the file respectively.  Marks are preserved when a new file is examined, so the ' command can be used to
              switch between input files.

       ^X^X   Same as single quote.

       ESC-m  Followed by any lowercase or uppercase letter, clears the mark identified by that letter.

       /pattern
              Search forward in the file for the N-th line containing the pattern.  N defaults to 1.  The pattern is a regular expression, as  recognized
              by  the  regular expression library supplied by your system.  The search starts at the first line displayed (but see the -a and -j options,
              which change this).

              Certain characters are special if entered at the beginning of the pattern; they modify the type of search rather than become  part  of  the
              pattern:

              ^N or !
                     Search for lines which do NOT match the pattern.

              ^E or *
                     Search  multiple files.  That is, if the search reaches the END of the current file without finding a match, the search continues in
                     the next file in the command line list.

              ^F or @
                     Begin the search at the first line of the FIRST file in the command line list, regardless of what  is  currently  displayed  on  the
                     screen or the settings of the -a or -j options.

              ^K     Highlight any text which matches the pattern on the current screen, but don't move to the first match (KEEP current position).

              ^R     Don't interpret regular expression metacharacters; that is, do a simple textual comparison.

              ^W     WRAP  around  the current file.  That is, if the search reaches the end of the current file without finding a match, the search con‐
                     tinues from the first line of the current file up to the line where it started.  If the ^W modifier is set, the ^E modifier  is  ig‐
                     nored.

       ?pattern
 Manual page less(1) line 130 (press h for help or q to quit)              Search  backward in the file for the N-th line containing the pattern.  The search starts at the last line displayed (but see the -a and -j
              options, which change this).

              Certain characters are special as in the / command:

              ^N or !
                     Search for lines which do NOT match the pattern.

              ^E or *
                     Search multiple files.  That is, if the search reaches the beginning of the current file without finding a match, the search contin‐
                     ues in the previous file in the command line list.

              ^F or @
                     Begin the search at the last line of the last file in the command line list, regardless of what is currently displayed on the screen
                     or the settings of the -a or -j options.

              ^K     As in forward searches.

              ^R     As in forward searches.

              ^W     WRAP around the current file.  That is, if the search reaches the beginning of the current file without finding a match, the  search
                     continues from the last line of the current file up to the line where it started.

       ESC-/pattern
              Same as "/*".

       ESC-?pattern
              Same as "?*".

       n      Repeat  previous  search, for N-th line containing the last pattern.  If the previous search was modified by ^N, the search is made for the
              N-th line NOT containing the pattern.  If the previous search was modified by ^E, the search continues in the next (or  previous)  file  if
              not satisfied in the current file.  If the previous search was modified by ^R, the search is done without using regular expressions.  There
              is no effect if the previous search was modified by ^F or ^K.

       N      Repeat previous search, but in the reverse direction.

       ESC-n  Repeat previous search, but crossing file boundaries.  The effect is as if the previous search were modified by *.

       ESC-N  Repeat previous search, but in the reverse direction and crossing file boundaries.

       ESC-u  Undo search highlighting.  Turn off highlighting of strings matching the current search pattern.  If highlighting is already off because of
              a  previous  ESC-u  command, turn highlighting back on.  Any search command will also turn highlighting back on.  (Highlighting can also be
              disabled by toggling the -G option; in that case search commands do not turn highlighting back on.)
 Manual page less(1) line 173 (press h for help or q to quit)
       ESC-U  Like ESC-u but also clears the saved search pattern.  If the status column is enabled via the -J option, this  clears  all  search  matches
              marked in the status column.

       &pattern
              Display only lines which match the pattern; lines which do not match the pattern are not displayed.  If pattern is empty (if you type & im‐
              mediately followed by ENTER), any filtering is turned off, and all lines are displayed.  While filtering is in effect, an ampersand is dis‐
              played  at  the  beginning  of the prompt, as a reminder that some lines in the file may be hidden.  Multiple & commands may be entered, in
              which case only lines which match all of the patterns will be displayed.

              Certain characters are special as in the / command:

              ^N or !
                     Display only lines which do NOT match the pattern.

              ^R     Don't interpret regular expression metacharacters; that is, do a simple textual comparison.

       :e [filename]
              Examine a new file.  If the filename is missing, the "current" file (see the :n and :p commands below) from the list of files in  the  com‐
              mand line is re-examined.  A percent sign (%) in the filename is replaced by the name of the current file.  A pound sign (#) is replaced by
              the name of the previously examined file.  However, two consecutive percent signs are simply replaced with a single percent sign.  This al‐
              lows  you  to enter a filename that contains a percent sign in the name.  Similarly, two consecutive pound signs are replaced with a single
              pound sign.  The filename is inserted into the command line list of files so that it can be seen by subsequent :n and :p commands.  If  the
              filename  consists  of several files, they are all inserted into the list of files and the first one is examined.  If the filename contains
              one or more spaces, the entire filename should be enclosed in double quotes (also see the -" option).

       ^X^V or E
              Same as :e.  Warning: some systems use ^V as a special literalization character.  On such systems, you may not be able to use ^V.

       :n     Examine the next file (from the list of files given in the command line).  If a number N is specified, the N-th next file is examined.

       :p     Examine the previous file in the command line list.  If a number N is specified, the N-th previous file is examined.

       :x     Examine the first file in the command line list.  If a number N is specified, the N-th file in the list is examined.

       :d     Remove the current file from the list of files.

       t      Go to the next tag, if there were more than one matches for the current tag.  See the -t option for more details about tags.

       T      Go to the previous tag, if there were more than one matches for the current tag.

       = or ^G or :f
              Prints some information about the file being viewed, including its name and the line number and byte offset of the bottom line  being  dis‐
 Manual page less(1) line 216 (press h for help or q to quit)              played.   If  possible,  it  also prints the length of the file, the number of lines in the file and the percent of the file above the last
              displayed line.

       -      Followed by one of the command line option letters (see OPTIONS below), this will change the setting of that option and print a message de‐
              scribing  the  new setting.  If a ^P (CONTROL-P) is entered immediately after the dash, the setting of the option is changed but no message
              is printed.  If the option letter has a numeric value (such as -b or -h), or a string value (such as -P or -t), a new value may be  entered
              after the option letter.  If no new value is entered, a message describing the current setting is printed and nothing is changed.

       --     Like  the  -  command, but takes a long option name (see OPTIONS below) rather than a single option letter.  You must press ENTER or RETURN
              after typing the option name.  A ^P immediately after the second dash suppresses printing of a message describing the new  setting,  as  in
              the - command.

       -+     Followed by one of the command line option letters this will reset the option to its default setting and print a message describing the new
              setting.  (The "-+X" command does the same thing as "-+X" on the command line.)  This does not work for string-valued options.

       --+    Like the -+ command, but takes a long option name rather than a single option letter.

       -!     Followed by one of the command line option letters, this will reset the option to the "opposite" of its default setting and print a message
              describing the new setting.  This does not work for numeric or string-valued options.

       --!    Like the -! command, but takes a long option name rather than a single option letter.

       _      (Underscore.)  Followed by one of the command line option letters, this will print a message describing the current setting of that option.
              The setting of the option is not changed.

       __     (Double underscore.)  Like the _ (underscore) command, but takes a long option name rather than a single option letter.  You must press EN‐
              TER or RETURN after typing the option name.

       +cmd   Causes  the  specified  cmd  to  be  executed each time a new file is examined.  For example, +G causes less to initially display each file
              starting at the end rather than the beginning.

       V      Prints the version number of less being run.

       q or Q or :q or :Q or ZZ
              Exits less.

       The following four commands may or may not be valid, depending on your particular installation.

       v      Invokes an editor to edit the current file being viewed.  The editor is taken from the environment variable VISUAL if defined, or EDITOR if
              VISUAL  is not defined, or defaults to "vi" if neither VISUAL nor EDITOR is defined.  See also the discussion of LESSEDIT under the section
              on PROMPTS below.

       ! shell-command
 Manual page less(1) line 259 (press h for help or q to quit)              Invokes a shell to run the shell-command given.  A percent sign (%) in the command is replaced by the name of the current  file.   A  pound
              sign  (#)  is replaced by the name of the previously examined file.  "!!" repeats the last shell command.  "!" with no shell command simply
              invokes a shell.  On Unix systems, the shell is taken from the environment variable SHELL, or defaults to "sh".  On MS-DOS  and  OS/2  sys‐
              tems, the shell is the normal command processor.

       | <m> shell-command
              <m>  represents any mark letter.  Pipes a section of the input file to the given shell command.  The section of the file to be piped is be‐
              tween the position marked by the letter and the current screen.  The entire current screen is included, regardless of  whether  the  marked
              position  is before or after the current screen.  <m> may also be ^ or $ to indicate beginning or end of file respectively.  If <m> is . or
              newline, the current screen is piped.

       s filename
              Save the input to a file.  This only works if the input is a pipe, not an ordinary file.

OPTIONS
       Command line options are described below.  Most options may be changed while less is running, via the "-" command.

       Most options may be given in one of two forms: either a dash followed by a single letter, or two dashes followed by a long option  name.   A  long
       option  name  may be abbreviated as long as the abbreviation is unambiguous.  For example, --quit-at-eof may be abbreviated --quit, but not --qui,
       since both --quit-at-eof and --quiet begin with --qui.  Some long option names are in uppercase, such as --QUIT-AT-EOF, as distinct  from  --quit-
       at-eof.   Such  option names need only have their first letter capitalized; the remainder of the name may be in either case.  For example, --Quit-
       at-eof is equivalent to --QUIT-AT-EOF.

       Options are also taken from the environment variable "LESS".  For example, to avoid typing "less -options ..." each  time  less  is  invoked,  you
       might tell csh:

       setenv LESS "-options"

       or if you use sh:

       LESS="-options"; export LESS

       On MS-DOS, you don't need the quotes, but you should replace any percent signs in the options string by double percent signs.

       The  environment variable is parsed before the command line, so command line options override the LESS environment variable.  If an option appears
       in the LESS variable, it can be reset to its default value on the command line by beginning the command line option with "-+".

       Some options like -k or -D require a string to follow the option letter.  The string for that option is considered to end when a dollar  sign  ($)
       is found.  For example, you can set two -D options on MS-DOS like this:

       LESS="Dn9.1$Ds4.1"

       If  the  --use-backslash  option  appears earlier in the options, then a dollar sign or backslash may be included literally in an option string by
 Manual page less(1) line 302 (press h for help or q to quit)       preceding it with a backslash.  If the --use-backslash option is not in effect, then backslashes are not treated specially, and there is no way to
       include a dollar sign in the option string.

       -? or --help
              This  option  displays a summary of the commands accepted by less (the same as the h command).  (Depending on how your shell interprets the
              question mark, it may be necessary to quote the question mark, thus: "-\?".)

       -a or --search-skip-screen
              By default, forward searches start at the top of the displayed screen and backwards searches start at the bottom of  the  displayed  screen
              (except for repeated searches invoked by the n or N commands, which start after or before the "target" line respectively; see the -j option
              for more about the target line).  The -a option causes forward searches to instead start at the bottom of the screen and backward  searches
              to start at the top of the screen, thus skipping all lines displayed on the screen.

       -A or --SEARCH-SKIP-SCREEN
              Causes  all  forward searches (not just non-repeated searches) to start just after the target line, and all backward searches to start just
              before the target line.  Thus, forward searches will skip part of the displayed screen (from the first line up to and including the  target
              line).   Similarly  backwards searches will skip the displayed screen from the last line up to and including the target line.  This was the
              default behavior in less versions prior to 441.

       -bn or --buffers=n
              Specifies the amount of buffer space less will use for each file, in units of kilobytes (1024 bytes).  By default 64 KB of buffer space  is
              used for each file (unless the file is a pipe; see the -B option).  The -b option specifies instead that n kilobytes of buffer space should
              be used for each file.  If n is -1, buffer space is unlimited; that is, the entire file can be read into memory.

       -B or --auto-buffers
              By default, when data is read from a pipe, buffers are allocated automatically as needed.  If a large amount of data is read from the pipe,
              this  can  cause  a large amount of memory to be allocated.  The -B option disables this automatic allocation of buffers for pipes, so that
              only 64 KB (or the amount of space specified by the -b option) is used for the pipe.  Warning: use of -B can result in  erroneous  display,
              since only the most recently viewed part of the piped data is kept in memory; any earlier data is lost.

       -c or --clear-screen
              Causes  full  screen repaints to be painted from the top line down.  By default, full screen repaints are done by scrolling from the bottom
              of the screen.

       -C or --CLEAR-SCREEN
              Same as -c, for compatibility with older versions of less.

       -d or --dumb
              The -d option suppresses the error message normally displayed if the terminal is dumb; that is, lacks some important  capability,  such  as
              the ability to clear the screen or scroll backward.  The -d option does not otherwise change the behavior of less on a dumb terminal.

       -Dxcolor or --color=xcolor
              Changes  the  color  of different parts of the displayed text.  x is a single character which selects the type of text whose color is being
 Manual page less(1) line 345 (press h for help or q to quit)       If  the  --use-backslash  option  appears earlier in the options, then a dollar sign or backslash may be included literally in an option string by

       LESS="Dn9.1$Ds4.1"

       is found.  For example, you can set two -D options on MS-DOS like this:
       Some options like -k or -D require a string to follow the option letter.  The string for that option is considered to end when a dollar  sign  ($)

       in the LESS variable, it can be reset to its default value on the command line by beginning the command line option with "-+".
       The  environment variable is parsed before the command line, so command line options override the LESS environment variable.  If an option appears

       On MS-DOS, you don't need the quotes, but you should replace any percent signs in the options string by double percent signs.

       LESS="-options"; export LESS

       or if you use sh:

       setenv LESS "-options"

       might tell csh:
       Options are also taken from the environment variable "LESS".  For example, to avoid typing "less -options ..." each  time  less  is  invoked,  you

       at-eof is equivalent to --QUIT-AT-EOF.
       at-eof.   Such  option names need only have their first letter capitalized; the remainder of the name may be in either case.  For example, --Quit-
       since both --quit-at-eof and --quiet begin with --qui.  Some long option names are in uppercase, such as --QUIT-AT-EOF, as distinct  from  --quit-
       option  name  may be abbreviated as long as the abbreviation is unambiguous.  For example, --quit-at-eof may be abbreviated --quit, but not --qui,
       Most options may be given in one of two forms: either a dash followed by a single letter, or two dashes followed by a long option  name.   A  long

       Command line options are described below.  Most options may be changed while less is running, via the "-" command.
OPTIONS

              Save the input to a file.  This only works if the input is a pipe, not an ordinary file.
       s filename

              newline, the current screen is piped.
              position  is before or after the current screen.  <m> may also be ^ or $ to indicate beginning or end of file respectively.  If <m> is . or
              tween the position marked by the letter and the current screen.  The entire current screen is included, regardless of  whether  the  marked
              <m>  represents any mark letter.  Pipes a section of the input file to the given shell command.  The section of the file to be piped is be‐
       | <m> shell-command

              tems, the shell is the normal command processor.
              invokes a shell.  On Unix systems, the shell is taken from the environment variable SHELL, or defaults to "sh".  On MS-DOS  and  OS/2  sys‐
              sign  (#)  is replaced by the name of the previously examined file.  "!!" repeats the last shell command.  "!" with no shell command simply
              Invokes a shell to run the shell-command given.  A percent sign (%) in the command is replaced by the name of the current  file.   A  pound
 Manual page less(1) line 302 (press h for help or q to quit)       ! shell-command

              on PROMPTS below.
              VISUAL  is not defined, or defaults to "vi" if neither VISUAL nor EDITOR is defined.  See also the discussion of LESSEDIT under the section
       v      Invokes an editor to edit the current file being viewed.  The editor is taken from the environment variable VISUAL if defined, or EDITOR if

       The following four commands may or may not be valid, depending on your particular installation.

              Exits less.
       q or Q or :q or :Q or ZZ

       V      Prints the version number of less being run.

              starting at the end rather than the beginning.
       +cmd   Causes  the  specified  cmd  to  be  executed each time a new file is examined.  For example, +G causes less to initially display each file

              TER or RETURN after typing the option name.
       __     (Double underscore.)  Like the _ (underscore) command, but takes a long option name rather than a single option letter.  You must press EN‐

              The setting of the option is not changed.
       _      (Underscore.)  Followed by one of the command line option letters, this will print a message describing the current setting of that option.

       --!    Like the -! command, but takes a long option name rather than a single option letter.

              describing the new setting.  This does not work for numeric or string-valued options.
       -!     Followed by one of the command line option letters, this will reset the option to the "opposite" of its default setting and print a message

       --+    Like the -+ command, but takes a long option name rather than a single option letter.

              setting.  (The "-+X" command does the same thing as "-+X" on the command line.)  This does not work for string-valued options.
       -+     Followed by one of the command line option letters this will reset the option to its default setting and print a message describing the new

              the - command.
              after typing the option name.  A ^P immediately after the second dash suppresses printing of a message describing the new  setting,  as  in
       --     Like  the  -  command, but takes a long option name (see OPTIONS below) rather than a single option letter.  You must press ENTER or RETURN

              after the option letter.  If no new value is entered, a message describing the current setting is printed and nothing is changed.
              is printed.  If the option letter has a numeric value (such as -b or -h), or a string value (such as -P or -t), a new value may be  entered
              scribing  the  new setting.  If a ^P (CONTROL-P) is entered immediately after the dash, the setting of the option is changed but no message
       -      Followed by one of the command line option letters (see OPTIONS below), this will change the setting of that option and print a message de‐

              displayed line.
              played.   If  possible,  it  also prints the length of the file, the number of lines in the file and the percent of the file above the last
 Manual page less(1) line 259 (press h for help or q to quit)              Invokes a shell to run the shell-command given.  A percent sign (%) in the command is replaced by the name of the current  file.   A  pound
              sign  (#)  is replaced by the name of the previously examined file.  "!!" repeats the last shell command.  "!" with no shell command simply
              invokes a shell.  On Unix systems, the shell is taken from the environment variable SHELL, or defaults to "sh".  On MS-DOS  and  OS/2  sys‐
              tems, the shell is the normal command processor.

       | <m> shell-command
              <m>  represents any mark letter.  Pipes a section of the input file to the given shell command.  The section of the file to be piped is be‐
              tween the position marked by the letter and the current screen.  The entire current screen is included, regardless of  whether  the  marked
              position  is before or after the current screen.  <m> may also be ^ or $ to indicate beginning or end of file respectively.  If <m> is . or
              newline, the current screen is piped.

       s filename
              Save the input to a file.  This only works if the input is a pipe, not an ordinary file.

OPTIONS
       Command line options are described below.  Most options may be changed while less is running, via the "-" command.

       Most options may be given in one of two forms: either a dash followed by a single letter, or two dashes followed by a long option  name.   A  long
       option  name  may be abbreviated as long as the abbreviation is unambiguous.  For example, --quit-at-eof may be abbreviated --quit, but not --qui,
       since both --quit-at-eof and --quiet begin with --qui.  Some long option names are in uppercase, such as --QUIT-AT-EOF, as distinct  from  --quit-
       at-eof.   Such  option names need only have their first letter capitalized; the remainder of the name may be in either case.  For example, --Quit-
       at-eof is equivalent to --QUIT-AT-EOF.

       Options are also taken from the environment variable "LESS".  For example, to avoid typing "less -options ..." each  time  less  is  invoked,  you
       might tell csh:

       setenv LESS "-options"

       or if you use sh:

       LESS="-options"; export LESS

       On MS-DOS, you don't need the quotes, but you should replace any percent signs in the options string by double percent signs.

       The  environment variable is parsed before the command line, so command line options override the LESS environment variable.  If an option appears
       in the LESS variable, it can be reset to its default value on the command line by beginning the command line option with "-+".

       Some options like -k or -D require a string to follow the option letter.  The string for that option is considered to end when a dollar  sign  ($)
       is found.  For example, you can set two -D options on MS-DOS like this:

       LESS="Dn9.1$Ds4.1"

       If  the  --use-backslash  option  appears earlier in the options, then a dollar sign or backslash may be included literally in an option string by
 Manual page less(1) line 302 (press h for help or q to quit)       preceding it with a backslash.  If the --use-backslash option is not in effect, then backslashes are not treated specially, and there is no way to
       include a dollar sign in the option string.

       -? or --help
              This  option  displays a summary of the commands accepted by less (the same as the h command).  (Depending on how your shell interprets the
              question mark, it may be necessary to quote the question mark, thus: "-\?".)

       -a or --search-skip-screen
              By default, forward searches start at the top of the displayed screen and backwards searches start at the bottom of  the  displayed  screen
              (except for repeated searches invoked by the n or N commands, which start after or before the "target" line respectively; see the -j option
              for more about the target line).  The -a option causes forward searches to instead start at the bottom of the screen and backward  searches
              to start at the top of the screen, thus skipping all lines displayed on the screen.

       -A or --SEARCH-SKIP-SCREEN
              Causes  all  forward searches (not just non-repeated searches) to start just after the target line, and all backward searches to start just
              before the target line.  Thus, forward searches will skip part of the displayed screen (from the first line up to and including the  target
              line).   Similarly  backwards searches will skip the displayed screen from the last line up to and including the target line.  This was the
              default behavior in less versions prior to 441.

       -bn or --buffers=n
              Specifies the amount of buffer space less will use for each file, in units of kilobytes (1024 bytes).  By default 64 KB of buffer space  is
              used for each file (unless the file is a pipe; see the -B option).  The -b option specifies instead that n kilobytes of buffer space should
              be used for each file.  If n is -1, buffer space is unlimited; that is, the entire file can be read into memory.

       -B or --auto-buffers
              By default, when data is read from a pipe, buffers are allocated automatically as needed.  If a large amount of data is read from the pipe,
              this  can  cause  a large amount of memory to be allocated.  The -B option disables this automatic allocation of buffers for pipes, so that
              only 64 KB (or the amount of space specified by the -b option) is used for the pipe.  Warning: use of -B can result in  erroneous  display,
              since only the most recently viewed part of the piped data is kept in memory; any earlier data is lost.

       -c or --clear-screen
              Causes  full  screen repaints to be painted from the top line down.  By default, full screen repaints are done by scrolling from the bottom
              of the screen.

       -C or --CLEAR-SCREEN
              Same as -c, for compatibility with older versions of less.

       -d or --dumb
              The -d option suppresses the error message normally displayed if the terminal is dumb; that is, lacks some important  capability,  such  as
              the ability to clear the screen or scroll backward.  The -d option does not otherwise change the behavior of less on a dumb terminal.

       -Dxcolor or --color=xcolor
              Changes  the  color  of different parts of the displayed text.  x is a single character which selects the type of text whose color is being
 Manual page less(1) line 345 (press h for help or q to quit)              set:

              B      Binary characters.

              C      Control characters.

              E      Errors and informational messages.

              H      Header lines and columns, set via the --header option.

              M      Mark letters in the status column.

              N      Line numbers enabled via the -N option.

              P      Prompts.

              R      The rscroll character.

              S      Search results.

              W      The highlight enabled via the -w option.

              d      Bold text.

              k      Blinking text.

              s      Standout text.

              u      Underlined text.

              The uppercase letters can be used only when the --use-color option is enabled.  When text color is specified by both  an  uppercase  letter
              and a lowercase letter, the uppercase letter takes precedence.  For example, error messages are normally displayed as standout text.  So if
              both "s" and "E" are given a color, the "E" color applies to error messages, and the "s" color applies to other standout text.  The "d" and
              "u"  letters refer to bold and underline text formed by overstriking with backspaces (see the -u option), not to text using ANSI escape se‐
              quences with the -R option.

              A lowercase letter may be followed by a + to indicate that the normal format change and the specified color should both be used.  For exam‐
              ple,  -Dug  displays  underlined text as green without underlining; the green color has replaced the usual underline formatting.  But -Du+g
              displays underlined text as both green and in underlined format.

              color is either a 4-bit color string or an 8-bit color string:

              A 4-bit color string is zero, one or two characters, where the first character specifies the foreground color and the second specifies  the
 Manual page less(1) line 388 (press h for help or q to quit)              background color as follows:

              b      Blue

              c      Cyan

              g      Green

              k      Black

              m      Magenta

              r      Red

              w      White

              y      Yellow

              The  corresponding  upper-case letter denotes a brighter shade of the color.  For example, -DNGk displays line numbers as bright green text
              on a black background, and -DEbR displays error messages as blue text on a bright red background.  If either character is a "-" or is omit‐
              ted, the corresponding color is set to that of normal text.

              An  8-bit  color  string  is one or two decimal integers separated by a dot, where the first integer specifies the foreground color and the
              second specifies the background color.  Each integer is a value between 0 and 255 inclusive which selects a "CSI 38;5" color value (see
              https://en.wikipedia.org/wiki/ANSI_escape_code#SGR) If either integer is a "-" or is omitted, the corresponding color is  set  to  that  of
              normal  text.   On  MS-DOS  versions  of less, 8-bit color is not supported; instead, decimal values are interpreted as 4-bit CHAR_INFO.At‐
              tributes values (see
              https://docs.microsoft.com/en-us/windows/console/char-info-str).

       -e or --quit-at-eof
              Causes less to automatically exit the second time it reaches end-of-file.  By default, the only way to exit less is via the "q" command.

       -E or --QUIT-AT-EOF
              Causes less to automatically exit the first time it reaches end-of-file.

       -f or --force
              Forces non-regular files to be opened.  (A non-regular file is a directory or a device special file.)  Also suppresses the warning  message
              when a binary file is opened.  By default, less will refuse to open non-regular files.  Note that some operating systems will not allow di‐
              rectories to be read, even if -f is set.

       -F or --quit-if-one-screen
              Causes less to automatically exit if the entire file can be displayed on the first screen.

 Manual page less(1) line 431 (press h for help or q to quit)       -g or --hilite-search
              Normally, less will highlight ALL strings which match the last search command.  The -g option changes this behavior to highlight  only  the
              particular string which was found by the last search command.  This can cause less to run somewhat faster than the default.

       -G or --HILITE-SEARCH
              The -G option suppresses all highlighting of strings found by search commands.

       --old-bot
              Reverts to the old bottom of screen behavior.  This can be sometimes desirable  if  the  long lines are not wrapped  correctly when  reach‐
              ing  the  bottom  of  the  terminal,  while scrolling forward.

       -hn or --max-back-scroll=n
              Specifies a maximum number of lines to scroll backward.  If it is necessary to scroll backward more than n lines, the screen  is  repainted
              in a forward direction instead.  (If the terminal does not have the ability to scroll backward, -h0 is implied.)

       -i or --ignore-case
              Causes searches to ignore case; that is, uppercase and lowercase are considered identical.  This option is ignored if any uppercase letters
              appear in the search pattern; in other words, if a pattern contains uppercase letters, then that search does not ignore case.

       -I or --IGNORE-CASE
              Like -i, but searches ignore case even if the pattern contains uppercase letters.

       -jn or --jump-target=n
              Specifies a line on the screen where the "target" line is to be positioned.  The target line is the line specified by any command to search
              for  a  pattern,  jump to a line number, jump to a file percentage or jump to a tag.  The screen line may be specified by a number: the top
              line on the screen is 1, the next is 2, and so on.  The number may be negative to specify a line relative to the bottom of the screen:  the
              bottom line on the screen is -1, the second to the bottom is -2, and so on.  Alternately, the screen line may be specified as a fraction of
              the height of the screen, starting with a decimal point: .5 is in the middle of the screen, .3 is three tenths down from  the  first  line,
              and  so  on.  If the line is specified as a fraction, the actual line number is recalculated if the terminal window is resized, so that the
              target line remains at the specified fraction of the screen height.  If any form of the -j option is used, repeated forward  searches  (in‐
              voked with "n" or "N") begin at the line immediately after the target line, and repeated backward searches begin at the target line, unless
              changed by -a or -A.  For example, if "-j4" is used, the target line is the fourth line on the screen, so forward  searches  begin  at  the
              fifth  line  on the screen.  However nonrepeated searches (invoked with "/" or "?")  always begin at the start or end of the current screen
              respectively.

       -J or --status-column
              Displays a status column at the left edge of the screen.  The status column shows the lines that matched the current search, and any  lines
              that are marked (via the m or M command).

       -kfilename or --lesskey-file=filename
              Causes  less  to  open  and interpret the named file as a lesskey(1) binary file.  Multiple -k options may be specified.  If the LESSKEY or
              LESSKEY_SYSTEM environment variable is set, or if a lesskey file is found in a standard place (see KEY BINDINGS), it  is  also  used  as  a
              lesskey file.
 Manual page less(1) line 474 (press h for help or q to quit)[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ export LESS=""-"N"
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ prointenv LESS$LESS
printenv: invalid option -- 'N'
Try 'printenv --help' for more information.
[ec2-user@ip-172-31-3-152 ~]$ proint env L| grep LESS
LESS=-N
LESSOPEN=||/usr/bin/lesspipe.sh %s
[ec2-user@ip-172-31-3-152 ~]$ prk nirintenv
SHELL=/bin/bash
LESS=-N
HISTCONTROL=ignoredups
SYSTEMD_COLORS=false
HISTSIZE=1000
HOSTNAME=ip-172-31-3-152.ap-southeast-2.compute.internal
shell_var=test123
PWD=/home/ec2-user
LOGNAME=ec2-user
XDG_SESSION_TYPE=tty
MOTD_SHOWN=pam
HOME=/home/ec2-user
LANG=C.UTF-8
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:
SSH_CONNECTION=101.1.235.76 51075 172.31.3.152 22
XDG_SESSION_CLASS=user
SELINUX_ROLE_REQUESTED=
TERM=xterm
LESSOPEN=||/usr/bin/lesspipe.sh %s
USER=ec2-user
SELINUX_USE_CURRENT_RANGE=
SHLVL=1
XDG_SESSION_ID=3
XDG_RUNTIME_DIR=/run/user/1000
S_COLORS=auto
SSH_CLIENT=101.1.235.76 51075 22
which_declare=declare -f
PATH=/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
SELINUX_LEVEL_REQUESTED=
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
MAIL=/var/spool/mail/ec2-user
SSH_TTY=/dev/pts/1
BASH_FUNC_which%%=() {  ( alias;
 eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot "$@"
}
_=/usr/bin/printenv
[ec2-user@ip-172-31-3-152 ~]$ printenv | grep shell
shell_var=test123
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ printenv | grep shell | grep LESS$LESSexport LESS="-N"man lessless ssh_process.txtless ssh_process.txt
      1 root        2156  0.0  0.8  13316  8320 ?        Ss   09:34   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
      2 root        2477  0.0  1.0  14776 10016 ?        Ss   09:40   0:00 sshd: ec2-user [priv]
      3 ec2-user    2498  0.0  0.6  14776  6344 ?        S    09:40   0:00 sshd: ec2-user@pts/0
      4 ec2-user    3345  0.0  0.2 222316  2056 pts/0    S+   10:03   0:00 grep --color=auto ssh
ssh_process.txt (END)(END)(END)(END)(END)(END)(END)(END)...skipping...
      1 root        2156  0.0  0.8  13316  8320 ?        Ss   09:34   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
      2 root        2477  0.0  1.0  14776 10016 ?        Ss   09:40   0:00 sshd: ec2-user [priv]
      3 ec2-user    2498  0.0  0.6  14776  6344 ?        S    09:40   0:00 sshd: ec2-user@pts/0
      4 ec2-user    3345  0.0  0.2 222316  2056 pts/0    S+   10:03   0:00 grep --color=auto ssh
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
(END)(END)(END)(END)[ec2-user@ip-172-31-3-152 ~]$ [ec2-user@ip-172-31-3-152 ~]$ [ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ ls --l
total 8
-rw-r--r--. 1 ec2-user ec2-user   0 Feb 28 09:52 a
-rw-r--r--. 1 ec2-user ec2-user   6 Feb 28 09:57 b
-rw-r--r--. 1 ec2-user ec2-user 389 Feb 28 10:03 ssh_process.txt
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ lwichhich la
/usr/bin/which: no la in (/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin)
[ec2-user@ip-172-31-3-152 ~]$ which las
alias ls='ls --color=auto'
	/usr/bin/ls
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ echo $PATH
/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ PTHATH=^C
[ec2-user@ip-172-31-3-152 ~]$ PATH=/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbinn:/usr/local/sbin:/usr/sbinn:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin:/usr/local/sbin:/usr/sbin/usr/local/sbin:/usr/sbin
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ ls
-bash: ls: command not found
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 
[ec2-user@ip-172-31-3-152 ~]$ 